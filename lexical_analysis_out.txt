
  
    wikipedia
    enwiki
    https://en.wikipedia.org/wiki/main_page
    mediawiki 1.33.0-wmf.18
    first-letter
    
      media
      special
      
      talk
      user
      user talk
      wikipedia
      wikipedia talk
      file
      file talk
      mediawiki
      mediawiki talk
      template
      template talk
      help
      help talk
      category
      category talk
      portal
      portal talk
      book
      book talk
      draft
      draft talk
      education program
      education program talk
      timedtext
      timedtext talk
      module
      module talk
      gadget
      gadget talk
      gadget definition
      gadget definition talk
    
  
  
    lexical analysis
    0
    81251
    
      884475029
      872271284
      2019-02-21t21:42:01z
      
        citation bot
        7903804
      
      
      removed parameters. | you can [[wp:ucb|use this bot]] yourself. [[wp:dbug|report bugs here]]. | [[wp:ucb|user-activated]].
      wikitext
      text/x-wiki
      {{redirect|lexer|people with this name|lexer (surname)}}
in [[computer science]], '''lexical analysis''', '''lexing''' or '''tokenization''' is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens ([[string (computer science)|strings]] with an assigned and thus identified meaning). a program that performs lexical analysis may be termed a ''lexer'', ''tokenizer'',{{cite web|url=http://www.cs.man.ac.uk/~pjj/farrell/comp3.html|title=anatomy of a compiler and the tokenizer|website=www.cs.man.ac.uk}} or ''scanner'', though ''scanner'' is also a term for the first stage of a lexer. a lexer is generally combined with a [[parser]], which together analyze the [[syntax (programming languages)|syntax of programming language]]s, web pages, and so forth.

== applications ==
a lexer forms the first phase of a [[compiler frontend]] in modern processing. analysis generally occurs in one pass.

in older languages such as [[algol]], the initial stage was instead [[line reconstruction]], which performed [[stropping (syntax)|unstropping]] and removed whitespace and [[comment (computer programming)|comments]] (and had scannerless parsers, with no separate lexer). these steps are now done as part of the lexer.

lexers and parsers are most often used for compilers, but can be used for other computer language tools, such as [[prettyprint]]ers or [[lint (software)|linters]]. lexing can be divided into two stages: the ''scanning'', which segments the input string into syntactic units called ''lexemes'' and categorizes these into token classes; and the ''evaluating'', which converts lexemes into processed values.

lexers are generally quite simple, with most of the complexity deferred to the parser or [[semantic analysis (compilers)|semantic analysis]] phases, and can often be generated by a [[#lexer generator|lexer generator]], notably [[lex (software)|lex]] or derivatives. however, lexers can sometimes include some complexity, such as [[#phrase structure|phrase structure]] processing to make input easier and simplify the parser, and may be written partly or fully by hand, either to support more features or for performance.

== lexeme ==
a ''lexeme'' is a sequence of characters in the source program that matches the pattern for a token and is identified by the lexical analyzer as an instance of that token.page 111, "compilers principles, techniques, &amp; tools, 2nd ed." (worldcat) by aho, lam, sethi and ullman, as quoted in https://stackoverflow.com/questions/14954721/what-is-the-difference-between-token-and-lexeme

some authors term this a "token", using "token" interchangeably to represent the string being tokenized, and the token data structure resulting from putting this string through the [[#tokenization|tokenization]] process.{{cite web |url=http://perldoc.perl.org/perlinterp.html#parsing |title=perlinterp: perl 5 version 24.0 documentation |author=perl 5 porters |website=perldoc.perl.org - official documentation for the perl programming language |publisher=perldoc.perl.org |access-date=26 january 2017}}{{cite web |url=https://stackoverflow.com/questions/14954721/what-is-the-difference-between-token-and-lexeme#comment20999371_14958865 |title=what is the difference between token and lexeme? |author=guy coder |date=19 february 2013 |website=stack overflow |publisher=stack exchange inc |access-date=26 january 2017}}

the word lexeme in computer science is defined differently than [[lexeme]] in linguistics. a lexeme in computer science roughly corresponds to what might be termed a [[word]] in linguistics (the term [[word (computer architecture)|word]] in computer science has a different meaning than [[word]] in linguistics), although in some cases it may be more similar to a [[morpheme]].

== token ==

a ''lexical token'' or simply ''token'' is a [[string (computer science)|string]] with an assigned and thus identified meaning. it is structured as a pair consisting of a ''token name'' and an optional ''token value''. the token name is a category of lexical unit. common token names are
* identifier: names the programmer chooses;
* keyword: names already in the programming language;
* separator (also known as punctuators): punctuation characters and paired-delimiters;
* operator: symbols that operate on arguments and produce results;
* literal: numeric, logical, textual, reference literals;
* comment: line, block.

{|class="wikitable"
|+ examples of token values
! token name !! sample token values
|-
| identifier   || {{code|x}}, {{code|color}}, {{code|up}}
|-
| keyword      || {{code|2=c|if}}, {{code|2=c|while}}, {{code|2=c|return}}
|-
| separator    || }, (, ;
|-
| operator     || {{code|2=c|1=+}}, {{code|2=c|1=&lt;}}, {{code|2=c|1==}}
|-
| literal      || {{code|2=c|true}}, {{code|2=c|6.02e23}}, {{code|2=c|"music"}}
|-
| comment      || {{code|2=c|/* retrieves user data */}}, {{code|2=c|// must be negative}}
|}

consider this expression in the [[c (programming language)|c]] programming language:
: {{code|2=c|1=x = a + b * 2;}}

the lexical analysis of this expression yields the following sequence of tokens:
: [(identifier, x), (operator, =), (identifier, a), (operator, +), (identifier, b), (operator, *), (literal, 2), (separator, ;)]

a token name is what might be termed a [[part of speech]] in linguistics.

== lexical grammar ==
{{further|lexical grammar}}
the specification of a [[programming language]] often includes a set of rules, the [[lexical grammar]], which defines the lexical syntax. the lexical syntax is usually a [[regular language]], with the grammar rules consisting of [[regular expression]]s; they define the set of possible character sequences (lexemes) of a token. a lexer recognizes strings, and for each kind of string found the lexical program takes an action, most simply producing a token.

two important common lexical categories are [[whitespace character|white space]] and [[comment (computer programming)|comments]]. these are also defined in the grammar and processed by the lexer, but may be discarded (not producing any tokens) and considered ''non-significant'', at most separating two tokens (as in if&amp;nbsp;x instead of ifx). there are two important exceptions to this. first, in [[off-side rule]] languages that delimit [[block (programming)|blocks]] with indenting, initial whitespace is significant, as it determines block structure, and is generally handled at the lexer level; see [[#phrase structure|phrase structure]], below. secondly, in some uses of lexers, comments and whitespace must be preserved â€“ for examples, a [[prettyprint]]er also needs to output the comments and some debugging tools may provide messages to the programmer showing the original source code. in the 1960s, notably for [[algol]], whitespace and comments were eliminated as part of the [[line reconstruction]] phase (the initial phase of the [[compiler frontend]]), but this separate phase has been eliminated and these are now handled by the lexer.

== tokenization ==
''tokenization'' is the process of demarcating and possibly classifying sections of a string of input characters. the resulting tokens are then passed on to some other form of processing. the process can be considered a sub-task of [[parsing]] input.

(note: ''[[tokenization (data security)|tokenization]]'' in the field of computer security has a different meaning.)

for example, in the text [[string (computer science)|string]]:
: the quick brown fox jumps over the lazy dog

the string isn't implicitly segmented on spaces, as a [[natural language]] speaker would do. the raw input, the 43 characters, must be explicitly split into the 9 tokens with a given space delimiter (i.e., matching the string " " or regular expression /\s{1}/).

the tokens could be represented in [[xml]],



  the
  quick
  brown
  fox
  jumps
  over
  the
  lazy
  dog



or as an [[s-expression]],


 (sentence
   (word the)
   (word quick)
   (word brown) 
   (word fox)
   (word jumps)
   (word over) 
   (word the)
   (word lazy)
   (word dog))


when a token class represents more than one possible lexeme, the lexer often saves enough information to reproduce the original lexeme, so that it can be used in [[semantic analysis (compilers)|semantic analysis]]. the parser typically retrieves this information from the lexer and stores it in the [[abstract syntax tree]]. this is necessary in order to avoid information loss in the case of numbers and identifiers.

tokens are identified based on the specific rules of the lexer. some methods used to identify tokens include: [[regular expression]]s, specific sequences of characters termed a [[flag (computing)|flag]], specific separating characters called [[delimiter]]s, and explicit definition by a dictionary. special characters, including punctuation characters, are commonly used by lexers to identify tokens because of their natural use in written and programming languages.

tokens are often categorized by character content or by context within the data stream. categories are defined by the rules of the lexer. categories often involve grammar elements of the language used in the data stream. programming languages often categorize tokens as identifiers, operators, grouping symbols, or by [[data type]]. written languages commonly categorize tokens as nouns, verbs, adjectives, or punctuation. categories are used for post-processing of the tokens either by the parser or by other functions in the program.

a lexical analyzer generally does nothing with combinations of tokens, a task left for a [[parser]]. for example, a typical lexical analyzer recognizes parentheses as tokens, but does nothing to ensure that each "(" is matched with a ")".

when a lexer feeds tokens to the parser, the representation used is typically an enumerated list of number representations. for example, "identifier" is represented with 0, "assignment operator" with 1, "addition operator" with 2, etc.

tokens are defined often by [[regular expression]]s, which are understood by a lexical analyzer generator such as [[lex (software)|lex]]. the lexical analyzer (generated automatically by a tool like lex, or hand-crafted) reads in a stream of characters, identifies the [[#lexeme|lexemes]] in the stream, and categorizes them into tokens. this is termed ''tokenizing''. if the lexer finds an invalid token, it will report an error.

following tokenizing is [[parsing]]. from there, the interpreted data may be loaded into data structures for general use, interpretation, or [[compiling]].

=== scanner ===
the first stage, the ''scanner'', is usually based on a [[finite-state machine]] (fsm). it has encoded within it information on the possible sequences of characters that can be contained within any of the tokens it handles (individual instances of these character sequences are termed [[#lexeme|lexemes]]). for example, an ''integer'' token may contain any sequence of [[numerical digit]] characters.  in many cases, the first non-whitespace character can be used to deduce the kind of token that follows and subsequent input characters are then processed one at a time until reaching a character that is not in the set of characters acceptable for that token (this is termed the ''[[maximal munch]]'', or ''longest match'', rule). in some languages, the lexeme creation rules are more complex and may involve [[backtracking]] over previously read characters. for example, in c, one 'l' character is not enough to distinguish between an identifier that begins with 'l' and a wide-character string literal.

=== evaluator ===
a [[#lexeme|lexeme]], however, is only a string of characters known to be of a certain kind (e.g., a string literal, a sequence of letters). in order to construct a token, the lexical analyzer needs a second stage, the ''evaluator'', which goes over the characters of the lexeme to produce a ''value''. the lexeme's type combined with its value is what properly constitutes a token, which can be given to a parser. some tokens such as parentheses do not really have values, and so the evaluator function for these can return nothing: only the type is needed. similarly, sometimes evaluators can suppress a lexeme entirely, concealing it from the parser, which is useful for whitespace and comments. the evaluators for identifiers are usually simple (literally representing the identifier), but may include some [[stropping (syntax)|unstropping]]. the evaluators for [[integer literal]]s may pass the string on (deferring evaluation to the semantic analysis phase), or may perform evaluation themselves, which can be involved for different bases or floating point numbers. for a simple quoted string literal, the evaluator needs to remove only the quotes, but the evaluator for an [[string literal#escape sequences|escaped string literal]] incorporates a lexer, which unescapes the escape sequences.

for example, in the source code of a computer program, the string
:  {{code|2=c|1=net_worth_future = (assets - liabilities);}}
might be converted into the following lexical token stream; whitespace is suppressed and special characters have no value:
 identifier net_worth_future
 equals
 open_parenthesis
 identifier assets
 minus
 identifier liabilities
 close_parenthesis
 semicolon

though it is possible and sometimes necessary, due to licensing restrictions of existing parsers or if the list of tokens is small, to write a lexer by hand, lexers are often generated by automated tools. these tools generally accept regular expressions that describe the tokens allowed in the input stream. each regular expression is associated with a [[formal grammar#the syntax of grammars|production rule]] in the lexical grammar of the programming language that evaluates the lexemes matching the regular expression. these tools may generate source code that can be compiled and executed or construct a [[state transition table]] for a [[finite-state machine]] (which is plugged into template code for compiling and executing).

regular expressions compactly represent patterns that the characters in lexemes might follow. for example, for an [[english language|english]]-based language, an identifier token might be any english alphabetic character or an underscore, followed by any number of instances of ascii alphanumeric characters and/or underscores. this could be represented compactly by the string {{code|[a-za-z_][a-za-z_0-9]*}}. this means "any character a-z, a-z or _, followed by 0 or more of a-z, a-z, _ or 0-9".

regular expressions and the finite-state machines they generate are not powerful enough to handle recursive patterns, such as "''n'' opening parentheses, followed by a statement, followed by ''n'' closing parentheses." they are unable to keep count, and verify that ''n'' is the same on both sides, unless a finite set of permissible values exists for ''n''. it takes a full parser to recognize such patterns in their full generality. a parser can push parentheses on a stack and then try to pop them off and see if the stack is empty at the end (see example{{cite web|url=http://mitpress.mit.edu/sicp/full-text/book/book-z-h-31.html#%25_sec_5.1.4|title=structure and interpretation of computer programs|website=mitpress.mit.edu}} in the ''[[structure and interpretation of computer programs]]'' book).

=== obstacles ===
typically, tokenization occurs at the word level. however, it is sometimes difficult to define what is meant by a "word". often a tokenizer relies on simple heuristics, for example:
* punctuation and whitespace may or may not be included in the resulting list of tokens.
* all contiguous strings of alphabetic characters are part of one token; likewise with numbers.
* tokens are separated by [[whitespace character|whitespace]] characters, such as a space or line break, or by punctuation characters.

in languages that use inter-word spaces (such as most that use the latin alphabet, and most programming languages), this approach is fairly straightforward. however, even here there are many edge cases such as [[poetic contraction|contraction]]s, [[hyphen|hyphenated words]], [[emoticons]], and larger constructs such as [[uri]]s (which for some purposes may count as single tokens). a classic example is "new york-based", which a naive tokenizer may break at the space even though the better break is (arguably) at the hyphen.
 
tokenization is particularly difficult for languages written in [[scriptio continua]] which exhibit no word boundaries such as [[ancient greek]], [[chinese language|chinese]],huang, c., simon, p., hsieh, s., &amp; prevot, l. (2007) [http://www.aclweb.org/anthology/p/p07/p07-2018.pdf rethinking chinese word segmentation: tokenization, character classification, or word break identification] or [[thai language|thai]]. [[agglutinative language]]s, such as korean, also make tokenization tasks complicated.

some ways to address the more difficult problems include developing more complex heuristics, querying a table of common special-cases, or fitting the tokens to a [[language model]] that identifies collocations in a later processing step.

=== software ===
* [http://opennlp.apache.org/index.html apache opennlp] includes rule based and statistical tokenizers which support many languages
* [http://tokenizer.tool.uniwits.com u-tokenizer] is an api over http that can cut mandarin and japanese sentences at word boundary.  english is supported as well.
* [https://dev.havenondemand.com/apis/tokenizetext#overview hpe haven ondemand text tokenization api] (commercial product, with freemium access) uses advanced probabilistic concept modelling to determine the weight that the term holds in the specified text indexes
* the [[lex (software)|lex]] tool and its compiler is designed to generate code for fast lexical analysers based on a formal description of the lexical syntax. it is generally considered insufficient for applications with a complex set of lexical rules and severe performance requirements. for example, the [[gnu compiler collection]] (gcc) uses hand-written lexers.

== lexer generator ==
{{see also|parser generator}}
lexers are often generated by a ''lexer generator'', analogous to [[parser generator]]s, and such tools often come together. the most established is [[lex (software)|lex]], paired with the [[yacc]] parser generator, and the free equivalents [[flex lexical analyser|flex]]/bison. these generators are a form of [[domain-specific language]], taking in a lexical specification â€“ generally regular expressions with some markup â€“ and emitting a lexer.

these tools yield very fast development, which is very important in early development, both to get a working lexer and because a language specification may change often. further, they often provide advanced features, such as pre- and post-conditions which are hard to program by hand. however, an automatically generated lexer may lack flexibility, and thus may require some manual modification, or an all-manually written lexer.

lexer performance is a concern, and optimizing is worthwhile, more so in stable languages where the lexer is run very often (such as c or html). lex/flex-generated lexers are reasonably fast, but improvements of two to three times are possible using more tuned generators. hand-written lexers are sometimes used, but modern lexer generators produce faster lexers than most hand-coded ones. the lex/flex family of generators uses a table-driven approach which is much less efficient than the directly coded approach.{{dubious|table-driven vs directly coded|date=may 2010}} with the latter approach the generator produces an engine that directly jumps to follow-up states via goto statements. tools like re2c{{cite journal |last1= bumbulis |first1= p. |last2= cowan |first2= d. d. |doi= 10.1145/176454.176487 |title= re2c: a more versatile scanner generator |journal= acm letters on programming languages and systems |volume= 2 |issue= 1â€“4 |pages= 70â€“84 |date= marâ€“dec 1993}} have proven to produce engines that are between two and three times faster than flex produced engines.{{citation needed|date=april 2008}} it is in general difficult to hand-write analyzers that perform better than engines generated by these latter tools.

=== list of lexer generators ===
{{example farm|section|date=september 2018}}
{{see also|list of parser generators}}
* [[antlr]] â€“ can generate lexical analyzers and parsers
* dfastar â€“ generates dfa matrix table-driven lexers in c++
* [[flex lexical analyser|flex]] â€“ variant of the classic ''[[lex (software)|lex]]'' for c/c++
* [[ragel]] â€“ state machine and lexer generator with output in c, c++, and assembly
* [[re2c]] â€“ lexer generator for [[c (programming language)|c]] and [[c++]]

the following lexical analysers can handle [[unicode]]:
* [[javacc]] â€“ generates lexical analyzers written in java
* [https://github.com/jflex-de/jflex jflex] â€“ lexical analyzer generator for java
* annoflex - annotation-based code generator for lexical scanners for java
* [https://github.com/genivia/re-flex re/flex] - a fast variant of lex/flex for c++ generates scanners with tables or direct code
* [http://quex.sourceforge.net/ quex] â€“ fast universal lexical analyzer generator for c and c++ written in python
* fslex â€“ lexer generator for byte and unicode character input for f#
* [[re2c]] â€“ lexer generator for [[c (programming language)|c]] and [[c++]][http://re2c.org/manual/features/encodings/encodings.html], re2c manual
* [[ply (python lex-yacc)|ply]] -  the python module ply.lex enables the lexical analysis part

== phrase structure ==
lexical analysis mainly segments the input stream of characters into tokens, simply grouping the characters into pieces and categorizing them. however, the lexing may be significantly more complex; most simply, lexers may omit tokens or insert added tokens. omitting tokens, notably whitespace and comments, is very common, when these are not needed by the compiler. less commonly, added tokens may be inserted. this is done mainly to group tokens into [[statement (computer science)|statements]], or statements into blocks, to simplify the parser.

=== line continuation ===
[[line continuation]] is a feature of some languages where a newline is normally a statement terminator. most often, ending a line with a backslash (immediately followed by a [[newline]]) results in the line being ''continued'' â€“ the following line is ''joined'' to the prior line. this is generally done in the lexer: the backslash and newline are discarded, rather than the newline being tokenized. examples include [[bash (unix shell)|bash]],''[https://www.gnu.org/software/bash/manual/bashref.html bash reference manual]'', [https://www.gnu.org/software/bash/manual/bashref.html#escape-character 3.1.2.1 escape character] other shell scripts and python.{{cite web|url=https://docs.python.org/|title=3.6.4 documentation|website=docs.python.org}}

=== semicolon insertion ===
many languages use the semicolon as a statement terminator. most often this is mandatory, but in some languages the semicolon is optional in many contexts. this is mainly done at the lexer level, where the lexer outputs a semicolon into the token stream, despite one not being present in the input character stream, and is termed ''semicolon insertion'' or ''automatic semicolon insertion''. in these cases, semicolons are part of the formal phrase grammar of the language, but may not be found in input text, as they can be inserted by the lexer. optional semicolons or other terminators or separators are also sometimes handled at the parser level, notably in the case of [[trailing comma]]s or semicolons.

semicolon insertion is a feature of [[bcpl]] and its distant descendent [[go (programming language)|go]],''[http://golang.org/doc/effective_go.html effective go]'', "[http://golang.org/doc/effective_go.html#semicolons semicolons]" though it is absent in b or c."[https://groups.google.com/forum/#!topic/golang-nuts/xumrwi0q8uk semicolons in go]", golang-nuts, rob 'commander' pike, 12/10/09 semicolon insertion is present in [[javascript]], though the rules are somewhat complex and much-criticized; to avoid bugs, some recommend always using semicolons, while others use initial semicolons, termed [[defensive semicolon]]s, at the start of potentially ambiguous statements.

semicolon insertion (in languages with semicolon-terminated statements) and line continuation (in languages with newline-terminated statements) can be seen as complementary: semicolon insertion adds a token, even though newlines generally do ''not'' generate tokens, while line continuation prevents a token from being generated, even though newlines generally ''do'' generate tokens.

=== off-side rule ===
{{further|off-side rule}}
the [[off-side rule]] (blocks determined by indenting) can be implemented in the lexer, as in [[python (programming language)|python]], where increasing the indenting results in the lexer emitting an indent token, and decreasing the indenting results in the lexer emitting a dedent token. these tokens correspond to the opening brace { and closing brace } in languages that use braces for blocks, and means that the phrase grammar does not depend on whether braces or indenting are used. this requires that the lexer hold state, namely the current indent level, and thus can detect changes in indenting when this changes, and thus the lexical grammar is not [[context-free grammar|context-free]]: indentâ€“dedent depend on the contextual information of prior indent level.

== context-sensitive lexing ==
generally lexical grammars are context-free, or almost so, and thus require no looking back or ahead, or backtracking, which allows a simple, clean, and efficient implementation. this also allows simple one-way communication from lexer to parser, without needing any information flowing back to the lexer.

there are exceptions, however. simple examples include: semicolon insertion in go, which requires looking back one token; concatenation of consecutive string literals in python, which requires holding one token in a buffer before emitting it (to see if the next token is another string literal); and the off-side rule in python, which requires maintaining a count of indent level (indeed, a stack of each indent level). these examples all only require lexical context, and while they complicate a lexer somewhat, they are invisible to the parser and later phases.

a more complex example is [[the lexer hack]] in c, where the token class of a sequence of characters cannot be determined until the semantic analysis phase, since typedef names and variable names are lexically identical but constitute different token classes. thus in the hack, the lexer calls the semantic analyzer (say, symbol table) and checks if the sequence requires a typedef name. in this case, information must flow back not from the parser only, but from the semantic analyzer back to the lexer, which complicates design.

== notes ==
{{notelist}}

== references ==
{{reflist}}

===sources===
{{refbegin}}
* ''compiling with c# and java'', pat terry, 2005, {{isbn|032126360x}}
* ''algorithms + data structures = programs'', niklaus wirth, 1975, {{isbn|0-13-022418-9}}
* ''compiler construction'', niklaus wirth, 1996, {{isbn|0-201-40353-6}}
* sebesta, r. w. (2006). concepts of programming languages (seventh edition) pp.&amp;nbsp;177. boston: pearson/addison-wesley.
{{refend}}

== external links ==
* {{cite journal |url= http://people.cs.nctu.edu.tw/~wuuyang/homepage/papers/applicability2002.ps |first1= w. |last1= yang |first2= chey-woei |last2= tsay |first3= jien-tsai |last3= chan |title= on the applicability of the longest-match rule in lexical analysis |journal= computer languages, systems &amp; structures |volume= 28 |issue= 3 |pages= 273&amp;ndash;288 |date= 2002 |id= nsc 86-2213-e-009-021 and nsc 86-2213-e-009-079 |doi= 10.1016/s0096-0551(02)00014-0 }}
* {{cite web |url= https://www.ibm.com/developerworks/community/blogs/nlp/entry/tokenization |title= the art of tokenization |first= craig |last= trim |date= jan 23, 2013 |publisher= ibm |work= developer works}}
* [http://www.gabormelli.com/rkb/word_mention_segmentation_task word mention segmentation task], an analysis

{{defaultsort:lexical analysis}}
[[category:compiler construction]]
[[category:programming language implementation]]
[[category:parsing]]
      k7von5udcv6g3jh2y85uhb58pbww2qi
    
  

